name: Deploy Dev (SSM + EC2 Docker)

on:
  push:
    branches: [ "dev" ]

jobs:
  deploy-dev:
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - uses: actions/checkout@v4

      - name: Set Image Tag (dev-<short_sha>)
        run: |
          SHORT_SHA=$(echo "${GITHUB_SHA}" | cut -c1-7)
          echo "IMAGE_TAG=dev-${SHORT_SHA}" >> $GITHUB_ENV

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_USER }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Build & Push (GHCR)
        run: |
          IMAGE="ghcr.io/${{ secrets.GHCR_USER }}/book-preprocessing-worker:${IMAGE_TAG}"
          docker build -t "$IMAGE" .
          docker push "$IMAGE"

          # 선택: dev-latest 유지(편의)
          docker tag "$IMAGE" "ghcr.io/${{ secrets.GHCR_USER }}/book-preprocessing-worker:dev-latest"
          docker push "ghcr.io/${{ secrets.GHCR_USER }}/book-preprocessing-worker:dev-latest"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id:     ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region:            ${{ secrets.AWS_REGION }}

      - name: Deploy on EC2 via SSM (docker pull/run)
        id: ssm
        env:
          INSTANCE_ID: ${{ secrets.DEV_EC2_INSTANCE_ID }}
          GHCR_USER:   ${{ secrets.GHCR_USER }}
          GHCR_TOKEN:  ${{ secrets.GHCR_TOKEN }}
          IMAGE_TAG:   ${{ env.IMAGE_TAG }}
          KAFKA_BOOTSTRAP_SERVERS: ${{ secrets.KAFKA_BOOTSTRAP_SERVERS }}
          KAFKA_USERNAME:          ${{ secrets.KAFKA_USERNAME }}
          KAFKA_PASSWORD:          ${{ secrets.KAFKA_PASSWORD }}
        run: |
          set -euo pipefail
          IMAGE="ghcr.io/${GHCR_USER}/book-preprocessing-worker:${IMAGE_TAG}"

          # SSM에 보낼 스크립트(EC2에서 실행됨)
          cat > /tmp/ssm-dev-deploy.sh <<'EOS'
          set -euo pipefail

          echo "Login GHCR..."
          echo "${GHCR_TOKEN}" | docker login ghcr.io -u "${GHCR_USER}" --password-stdin

          echo "Pull image: ${IMAGE}"
          docker pull "${IMAGE}"

          echo "Stop/Rm old container..."
          docker stop book-preprocessing-worker || true
          docker rm book-preprocessing-worker || true

          echo "Run new container..."
          docker run -d \
            --name book-preprocessing-worker \
            -p 9002:9002 \
            -e SPRING_PROFILES_ACTIVE=dev \
            -e KAFKA_BOOTSTRAP_SERVERS="${KAFKA_BOOTSTRAP_SERVERS}" \
            -e KAFKA_USERNAME="${KAFKA_USERNAME}" \
            -e KAFKA_PASSWORD="${KAFKA_PASSWORD}" \
            --memory="512m" \
            --cpus="0.5" \
            --restart unless-stopped \
            "${IMAGE}"

          docker image prune -f

          echo "Healthcheck..."
          for i in {1..12}; do
            if curl -sf http://localhost:9002/actuator/health > /dev/null; then
              echo "✅ Service is healthy"
              exit 0
            fi
            echo "Waiting... ($i/12)"
            sleep 5
          done

          echo "❌ Health check failed"
          docker logs book-preprocessing-worker | tail -200
          exit 1
          EOS

          # 환경변수 삽입(템플릿 치환 개념: 로컬에서 값 주입 후 SSM 실행)
          export IMAGE
          envsubst < /tmp/ssm-dev-deploy.sh > /tmp/ssm-dev-deploy.rendered.sh

          COMMAND_ID=$(aws ssm send-command \
            --instance-ids "${INSTANCE_ID}" \
            --document-name "AWS-RunShellScript" \
            --comment "Dev deploy book-preprocessing-worker ${IMAGE_TAG}" \
            --parameters commands="bash -lc '$(cat /tmp/ssm-dev-deploy.rendered.sh | sed "s/'/'\\\\''/g")'" \
            --query "Command.CommandId" --output text)

          echo "COMMAND_ID=${COMMAND_ID}" >> $GITHUB_OUTPUT

          echo "Waiting for command to finish..."
          aws ssm wait command-executed --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}" || true

          STATUS=$(aws ssm get-command-invocation \
            --command-id "${COMMAND_ID}" \
            --instance-id "${INSTANCE_ID}" \
            --query "Status" --output text)

          echo "SSM Status: ${STATUS}"

          if [[ "${STATUS}" != "Success" ]]; then
            echo "---- STDOUT ----"
            aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}" --query "StandardOutputContent" --output text || true
            echo "---- STDERR ----"
            aws ssm get-command-invocation --command-id "${COMMAND_ID}" --instance-id "${INSTANCE_ID}" --query "StandardErrorContent" --output text || true
            exit 1
          fi

      - name: Slack notify on failure (dev)
        if: failure()
        uses: slackapi/slack-github-action@v1.27.0
        with:
          payload: |
            {
              "text": ":x: *DEV 배포 실패*",
              "blocks": [
                { "type": "section", "text": { "type": "mrkdwn", "text": ":x: *DEV 배포 실패*\n*Repo:* `${{ github.repository }}`\n*Branch:* `${{ github.ref_name }}`\n*Commit:* `${{ github.sha }}`\n*Actor:* `${{ github.actor }}`" } },
                { "type": "section", "text": { "type": "mrkdwn", "text": "*Run:* ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\n*SSM CommandId:* `${{ steps.ssm.outputs.COMMAND_ID }}`" } }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}